!! Copyright (C) 2019 N. Tancogne-Dejean
!! Copyright (C) 2020 M. Oliveira
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!

#include "global.h"

module system_abst_oct_m
  use global_oct_m
  use interaction_abst_oct_m
  use messages_oct_m
  use namespace_oct_m
  use linked_list_oct_m
  use observable_oct_m
  use profiling_oct_m
  use propagator_abst_oct_m
  use simulation_clock_oct_m

  implicit none

  private
  public ::               &
    system_abst_t

  type, abstract :: system_abst_t
    private
    type(namespace_t),   public :: namespace

    class(propagator_abst_t), pointer, public :: prop
    type(simulation_clock_t),          public :: clock

    integer, public :: n_interactions

    integer :: accumulated_loop_ticks

    type(observable_t), public :: observables(MAX_OBSERVABLES)

  contains
    procedure :: dt_operation =>  system_dt_operation
    procedure :: set_propagator => system_set_propagator
    procedure :: init_clock => system_init_clock
    procedure(system_add_interaction_partner),        deferred :: add_interaction_partner
    procedure(system_has_interaction),                deferred :: has_interaction
    procedure(system_do_td_op),                       deferred :: do_td_operation
    procedure(system_update_interaction_as_partner),  deferred :: update_interaction_as_partner
    procedure(system_update_interactions),            deferred :: update_interactions
    procedure(system_write_td_info),                  deferred :: write_td_info
    procedure(system_is_tolerance_reached),           deferred :: is_tolerance_reached
    procedure(system_store_current_status),           deferred :: store_current_status
    procedure(system_get_interaction_partner),        deferred :: get_interaction_partner
    procedure(system_update_observables_as_system),   deferred :: update_observables_as_system
    procedure(system_update_observables_as_partner),  deferred :: update_observables_as_partner
    procedure(system_reset_protected_observable_clocks), deferred :: reset_protected_observable_clocks
    procedure(system_init_interaction_clocks),        deferred :: init_interaction_clocks
  end type system_abst_t

  abstract interface
    subroutine system_add_interaction_partner(this, partner)
      import system_abst_t
      class(system_abst_t), target,    intent(inout) :: this
      class(system_abst_t), target,    intent(in)    :: partner
    end subroutine system_add_interaction_partner

    logical function system_has_interaction(this, interaction)
      import system_abst_t
      import interaction_abst_t
      class(system_abst_t),      intent(in) :: this
      class(interaction_abst_t), intent(in) :: interaction
    end function system_has_interaction

    subroutine system_do_td_op(this, operation)
      import system_abst_t
      class(system_abst_t), intent(inout) :: this
      integer             , intent(in)    :: operation
    end subroutine system_do_td_op

    subroutine system_update_interaction_as_partner(this, interaction)
      import system_abst_t
      import interaction_abst_t
      class(system_abst_t),      intent(in)    :: this
      class(interaction_abst_t), intent(inout) :: interaction
    end subroutine system_update_interaction_as_partner

    logical function system_update_interactions(this)
      import system_abst_t
      class(system_abst_t),      intent(inout) :: this
    end function system_update_interactions

    subroutine system_write_td_info(this)
      import system_abst_t
      class(system_abst_t), intent(in) :: this
    end subroutine system_write_td_info

    logical function system_is_tolerance_reached(this, tol)
      import system_abst_t
      class(system_abst_t), intent(in) :: this
      FLOAT,                intent(in) :: tol
    end function system_is_tolerance_reached

    subroutine system_store_current_status(this)
      import system_abst_t
      class(system_abst_t), intent(inout) :: this
    end subroutine system_store_current_status

    function system_get_interaction_partner(this, iint) result(partner)
      import system_abst_t
      class(system_abst_t), intent(in) :: this
      integer,              intent(in) :: iint
      class(system_abst_t), pointer :: partner
    end function system_get_interaction_partner

    subroutine system_update_observables_as_system(this, clock)
      import system_abst_t
      import simulation_clock_t
      class(system_abst_t),      intent(inout) :: this
      class(simulation_clock_t), intent(inout) :: clock
    end subroutine system_update_observables_as_system

    subroutine system_update_observables_as_partner(this, interaction, clock)
      import system_abst_t
      import interaction_abst_t
      import simulation_clock_t
      class(system_abst_t),      intent(inout) :: this
      class(interaction_abst_t), intent(inout) :: interaction
      class(simulation_clock_t), intent(inout) :: clock
    end subroutine system_update_observables_as_partner

    subroutine system_reset_protected_observable_clocks(this, accumulated_ticks)
      import system_abst_t
      class(system_abst_t),      intent(inout) :: this
      integer,                   intent(in)    :: accumulated_ticks
    end subroutine system_reset_protected_observable_clocks

    subroutine system_init_interaction_clocks(this, dt, smallest_algo_dt)
      import system_abst_t
      class(system_abst_t),      intent(inout) :: this
      FLOAT                                    :: dt, smallest_algo_dt
    end subroutine system_init_interaction_clocks

  end interface

contains

  ! ---------------------------------------------------------
  subroutine system_dt_operation(this)
    class(system_abst_t),     intent(inout) :: this

    class(system_abst_t), pointer :: partner
    integer :: tdop, ii
    logical :: all_updated

    PUSH_SUB(system_dt_operation)

    tdop = this%prop%get_td_operation()
    select case(tdop)
    case(FINISHED)
      if (debug%info .and. .not. this%prop%step_is_done()) then
        message(1) = "Debug: Propagation step finished for " + trim(this%namespace%get())
        call messages_info(1)
      end if
      if(.not.this%prop%step_is_done()) then
        call this%clock%increment()
      end if
      call this%prop%finished()

      !DO OUTPUT HERE AND BROADCAST NEEDED QUANTITIES
      !ONLY IF WE ARE NOT YET FINISHED

    case(UPDATE_INTERACTIONS)
      if (debug%info) then
        message(1) = "Debug: Propagation step - Synchronizing time for " + trim(this%namespace%get())
        call messages_info(1)
      end if

      !We increment by one algorithmic step
      call this%prop%clock%increment()

      !I update my oservables that will be needed for computing the interaction
      call this%update_observables_as_system(this%prop%clock)
      
      all_updated = this%update_interactions()

      if(all_updated) then
        this%accumulated_loop_ticks = this%accumulated_loop_ticks + 1
        call this%prop%list%next()
      else
        call this%prop%clock%decrement()
      end if

    case(START_SCF_LOOP)
      ASSERT(this%prop%predictor_corrector)
      if (debug%info) then
        write(message(1), '(a,i3,a)') "Debug: SCF iter ", this%prop%scf_count, " for " + trim(this%namespace%get())
        call messages_info(1)
      end if

      call this%prop%save_scf_start()
 
      this%accumulated_loop_ticks = 0

    case(END_SCF_LOOP)
      !Here we first check if we did the maximum number of steps.
      !Otherwise, we need check the tolerance 
      if(this%prop%scf_count == this%prop%max_scf_count) then
        if (debug%info) then
          message(1) = "Debug: Max SCF Iter reached for " + trim(this%namespace%get())
          call messages_info(1)
        end if
        call this%prop%list%next()
      else
        !We reset the pointer to the begining of the scf loop
        if(this%is_tolerance_reached(this%prop%scf_tol)) then
          if (debug%info) then
            message(1) = "Debug: SCF tolerance reached for " + trim(this%namespace%get())
            call messages_info(1)
          end if
          call this%prop%list%next()
        else
          !We rewind the intrusction stack
          call this%prop%rewind_scf_loop()

          !We reset the clock
          call this%reset_protected_observable_clocks(this%accumulated_loop_ticks)
          do ii = 1, this%accumulated_loop_ticks
            call this%prop%clock%decrement()
          end do
          this%accumulated_loop_ticks = 0
          if (debug%info) then
            write(message(1), '(a,i3,a)') "Debug: SCF iter ", this%prop%scf_count, " for " + trim(this%namespace%get())
           call messages_info(1)
         end if 
        end if
      end if

    case(STORE_CURRENT_STATUS)
 
      if (debug%info) then
        message(1) = "Debug: Storing the current status for " + trim(this%namespace%get())
        call messages_info(1)
      end if

      call this%store_current_status()
      call this%prop%list%next()

    case default
      call this%do_td_operation(tdop)
    end select

    POP_SUB(system_dt_operation)
  end subroutine system_dt_operation

  ! ---------------------------------------------------------
  subroutine system_set_propagator(this, propagator)
    class(system_abst_t),             intent(inout) :: this
    class(propagator_abst_t), target, intent(in)    :: propagator

    PUSH_SUB(system_set_propagator)

    this%prop => propagator

    POP_SUB(system_set_propagator)
  end subroutine system_set_propagator

  ! ---------------------------------------------------------
  subroutine system_init_clock(this, dt, smallest_algo_dt)
    class(system_abst_t), intent(inout) :: this
    FLOAT                               :: dt, smallest_algo_dt

    PUSH_SUB(system_set_propagator)

    this%clock = simulation_clock_t(dt, smallest_algo_dt)
    this%prop%clock = simulation_clock_t(dt/this%prop%algo_steps, smallest_algo_dt)
    call this%init_interaction_clocks(dt, smallest_algo_dt) 

    POP_SUB(system_set_propagator)
  end subroutine system_init_clock

end module system_abst_oct_m

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
