!! Copyright (C) 2002-2006 M. Marques, A. Castro, A. Rubio, G. Bertsch
!!
!! This program is free software; you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation; either version 2, or (at your option)
!! any later version.
!!
!! This program is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with this program; if not, write to the Free Software
!! Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
!! 02110-1301, USA.
!!

! ---------------------------------------------------------
!> conjugate-gradients method.
subroutine X(eigensolver_cg2) (gr, st, hm, pre, tol, niter, converged, ik, diff, shift, orthogonalize_to_all, conjugate_direction)
  type(grid_t),           intent(in)    :: gr
  type(states_t),         intent(inout) :: st
  type(hamiltonian_t),    intent(in)    :: hm
  type(preconditioner_t), intent(in)    :: pre
  FLOAT,                  intent(in)    :: tol
  integer,                intent(inout) :: niter
  integer,                intent(inout) :: converged
  integer,                intent(in)    :: ik
  FLOAT,        optional, intent(out)   :: diff(:) !< (1:st%nst)
  FLOAT,pointer, optional, intent(in)   :: shift(:,:)
  logical, optional,      intent(in)    :: orthogonalize_to_all
  integer, optional,      intent(in)    :: conjugate_direction
  integer, parameter :: &
       CG_FR      = 1,   &
       CG_PR      = 2

  R_TYPE, allocatable :: h_psi(:,:), g(:,:), g0(:,:),  cg(:,:), h_cg(:,:), psi(:, :), psi2(:, :), g_prev(:,:)
  R_TYPE, allocatable :: h_psi2(:,:), ppsi2(:,:), psi_lam(:,:), cg_vec_lam(:,:)
  R_TYPE, allocatable :: lam(:), lam_conj(:), cg_phi(:)
  R_TYPE   :: es(2), a0, b0, gg, gg0, gg1, gamma, theta, norma
  FLOAT    :: cg0, e0, res, norm, alpha, beta, dot, old_res, old_energy, first_delta_e
  FLOAT    :: stheta, stheta2, ctheta, ctheta2, beta_rdmft
  integer  :: ist, iter, maxter, idim, ip, jst
  R_TYPE   :: sb(3)
  logical   :: fold_ ! use folded spectrum operator (H-shift)^2

  PUSH_SUB(X(eigensolver_cg2))

  ! if the optional shift argument is present, assume we are computing a folded spectrum 
  fold_ =  present(shift)

  ! make sure the passed optional pointer is allocated
  if(fold_) then
    ASSERT(associated(shift))
  end if
  maxter = niter
  niter = 0
  old_res = 10*tol

  SAFE_ALLOCATE(psi(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE(h_psi(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE(   cg(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE(    g(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE(   g0(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE(   g_prev(1:gr%mesh%np_part, 1:st%d%dim))
  SAFE_ALLOCATE( h_cg(1:gr%mesh%np_part, 1:st%d%dim))	
  if(fold_) then
    SAFE_ALLOCATE( psi2(1:gr%mesh%np_part, 1:st%d%dim))
  end if
  
! Modifications Nicole
	if(hm%theory_level == RDMFT) then
		SAFE_ALLOCATE(psi_lam(1:gr%mesh%np_part, 1:st%d%dim))
		SAFE_ALLOCATE(cg_vec_lam(1:gr%mesh%np_part, 1:st%d%dim))
		SAFE_ALLOCATE(lam(1:st%nst))
		SAFE_ALLOCATE(lam_conj(1:st%nst))
		SAFE_ALLOCATE(cg_phi(1:st%nst))
		SAFE_ALLOCATE(ppsi2(1:gr%mesh%np_part, 1:st%d%dim))
	end if
! End Nicole

  h_psi = R_TOTYPE(M_ZERO)
  cg    = R_TOTYPE(M_ZERO)
  g     = R_TOTYPE(M_ZERO)
  g0    = R_TOTYPE(M_ZERO)
  h_cg  = R_TOTYPE(M_ZERO)
  g_prev = R_TOTYPE(M_ZERO)

  ! Set the diff to zero, since it is intent(out)
  if(present(diff)) diff(1:st%nst) = M_ZERO

  ! Start of main loop, which runs over all the eigenvectors searched
  ASSERT(converged >= 0)
  eigenfunction_loop : do ist = converged + 1, st%nst
    h_psi = R_TOTYPE(M_ZERO)
    cg    = R_TOTYPE(M_ZERO)
    g     = R_TOTYPE(M_ZERO)
    g0    = R_TOTYPE(M_ZERO)
    h_cg  = R_TOTYPE(M_ZERO)
    g_prev = R_TOTYPE(M_ZERO)
    
! Modifications RDMFT	
		if(hm%theory_level == RDMFT) then
			psi_lam 		= R_TOTYPE(M_ZERO)
			cg_vec_lam 	= R_TOTYPE(M_ZERO) 
			lam					= R_TOTYPE(M_ZERO)
			lam_conj		= R_TOTYPE(M_ZERO)
			cg_phi			= R_TOTYPE(M_ZERO)
			ppsi2				= R_TOTYPE(M_ZERO)
		end if
! End RDMFT

    call states_get_state(st, gr%mesh, ist, ik, psi)

    ! Orthogonalize starting eigenfunctions to those already calculated...
    if(ist > 1) call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, psi, normalize = .true.)

! Modifications RDMFT
    ! Calculate starting gradient: |hpsi> = H|psi>
    if(hm%theory_level == RDMFT) then
	  ! In RDMFT some terms in the hamiltonian scale differently with occupation number
	  SAFE_ALLOCATE(h_psi2(1:gr%mesh%np_part, 1:st%d%dim))
	  
	  h_psi2 = R_TOTYPE(M_ZERO)
	  call X(hamiltonian_apply)(hm, gr%der, psi, h_psi, ist, ik, terms = TERM_KINETIC &
                                & + TERM_LOCAL_POTENTIAL + TERM_NON_LOCAL_POTENTIAL, set_occ = .true.)         !! 1-body+hartree ( hartree and external included in TERM_LOCAL_POTENTIAL)                                 
	  call X(hamiltonian_apply)(hm, gr%der, psi, h_psi2, ist, ik, terms = TERM_OTHERS, set_occ = .true.)	   !! exchange
		h_psi = h_psi + h_psi2
		
		SAFE_DEALLOCATE_A(h_psi2)
    else 
      call X(hamiltonian_apply)(hm, gr%der, psi, h_psi, ist, ik)
    endif
! End RDMFT

    if(fold_) then
      call X(hamiltonian_apply)(hm, gr%der, h_psi, psi2, ist, ik)
      ! h_psi = (H-shift)^2 psi 
      h_psi = psi2 - M_TWO*shift(ist,ik)*h_psi + shift(ist,ik)**2*psi
    end if

    ! Calculates starting eigenvalue: e(p) = <psi(p)|H|psi>
    st%eigenval(ist, ik) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi, h_psi))
    old_energy = st%eigenval(ist, ik)
    first_delta_e = M_ZERO

! Medifications RDMFT
		if(hm%theory_level == RDMFT) then
			cg_vec_lam = R_TOTYPE(M_ZERO) 
			do jst = 1, st%nst
				if (jst == ist) then
					lam(jst) = st%eigenval(ist, ik)
					lam_conj(jst) = st%eigenval(ist, ik)
				else
					call states_get_state(st, gr%mesh, jst, ik, psi_lam)
					
					! calculate <phi_j|H|phi_i>	=lam_ji
					lam(jst) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi_lam, h_psi))
					
					! calculate <phi_i|H|phi_j>=lam_ij
					ppsi2  = R_TOTYPE(M_ZERO)
					call X(hamiltonian_apply)(hm, gr%der, psi_lam, h_cg, jst, ik, terms = TERM_KINETIC &
																	& + TERM_LOCAL_POTENTIAL + TERM_NON_LOCAL_POTENTIAL, set_occ = .true.)                !! 1-body+hartree ( hartree and external included in TERM_LOCAL_POTENTIAL) 
					call X(hamiltonian_apply)(hm, gr%der, psi_lam, ppsi2, jst, ik, terms = TERM_OTHERS, set_occ = .true.)			 ! exchange
					h_cg = h_cg  + ppsi2
					
					lam_conj(jst) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi, h_cg))
					
					h_cg= R_TOTYPE(M_ZERO)
					
					! cg_vec including lambda but leaving out the diagonal part that needs to be adpated every iteration (note that only psi changes but lambda remains constant)
					forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
						cg_vec_lam(ip, idim) = cg_vec_lam(ip, idim) + lam_conj(jst)*psi_lam(ip, idim) !! works also with -lam
					end forall	
				end if
			end do
		end if
! End RDMFT

!!!!!!!!!!!!!!!!!!!! Starts iteration for this band !!!!!!!!!!!!!!!!!!!!
    iter_loop: do iter = 1, maxter
      ! need to save g from previous iteration for Polak-Ribiere method
      if(conjugate_direction == CG_PR) then
        if(iter /= 1) then
          g_prev = g
        else
          g_prev = M_ZERO
        end if
      end if

      ! PTA92, eq. 5.10
! Modifications RDMFT
			if(hm%theory_level == RDMFT) then
!				cg_vec_lam = R_TOTYPE(M_ZERO) 
!				do jst = 1, st%nst
!					if (jst == ist) then
!						psi_lam = psi
						
!						lam(jst) = st%eigenval(ist, ik)
!						lam_conj(jst) = st%eigenval(ist, ik)
!!						h_cg = h_psi
!					else
!						call states_get_state(st, gr%mesh, jst, ik, psi_lam)
						
!						! calculate <phi_j|H|phi_i>	=lam_ji
!						lam(jst) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi_lam, h_psi))
						
!						! calculate <phi_i|H|phi_j>=lam_ij
!						ppsi2  = R_TOTYPE(M_ZERO)
!						call X(hamiltonian_apply)(hm, gr%der, psi_lam, h_cg, jst, ik, terms = TERM_KINETIC &
!																		& + TERM_LOCAL_POTENTIAL + TERM_NON_LOCAL_POTENTIAL, set_occ = .true.)                !! 1-body+hartree ( hartree and external included in TERM_LOCAL_POTENTIAL) 
!						call X(hamiltonian_apply)(hm, gr%der, psi_lam, ppsi2, jst, ik, terms = TERM_OTHERS, set_occ = .true.)			 ! exchange
!						h_cg = h_cg  + ppsi2

!						lam_conj(jst) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi, h_cg))
				
!						h_cg= R_TOTYPE(M_ZERO)
!					end if						
				
!					forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
!						cg_vec_lam(ip, idim) = cg_vec_lam(ip, idim) + lam_conj(jst)*psi_lam(ip, idim) !! works also with -lam
!					end forall	
!				end do
				
				forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
					g(ip, idim) = h_psi(ip, idim) - cg_vec_lam(ip, idim) - lam_conj(jst)*psi(ip, idim)
				end forall

			else ! no RDMFT
				forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
					g(ip, idim) = h_psi(ip, idim) - st%eigenval(ist, ik)*psi(ip, idim)
				end forall 
			end if 
! End RDMFT

      ! PTA92, eq. 5.12
      ! Orthogonalize to all states -> not needed for good convergence
!      call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, g, normalize = .false., against_all=.true.)

      ! PTA92, eq. 5.17
      ! Approximate inverse preconditioner...
      call  X(preconditioner_apply)(pre, gr, hm, ik, g(:,:), g0(:,:))
      ! PTA92, eq. 5.18 (following 6 lines)
      dot = X(mf_dotp) (gr%mesh, st%d%dim, psi, g0)
      if(optional_default(orthogonalize_to_all, .false.)) then
        ! Orthogonalize to all states
        call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, g0, normalize = .false., against_all=.true.)
      else
        ! Orthogonalize to lowest eigenvalues (already calculated)
        if(ist > 1) call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, g0, normalize = .false.)
      end if

      do idim = 1, st%d%dim
        call lalg_axpy(gr%mesh%np, -dot, psi(:, idim), g0(:, idim))
      end do

      ! dot products needed for conjugate gradient
      gg = X(mf_dotp) (gr%mesh, st%d%dim, g0, g, reduce = .false.)
      if(conjugate_direction == CG_PR) then
        ! only needed for Polak-Ribiere
        if(iter /= 1) then
          gg1 = X(mf_dotp) (gr%mesh, st%d%dim, g0, g_prev, reduce = .false.)
        else
          gg1 = M_ZERO
        end if
      end if

      if(gr%mesh%parallel_in_domains) then
        sb(1) = gg1
        sb(2) = gg
        call comm_allreduce(gr%mesh%vp%comm, sb, dim = 2)
        gg1 = sb(1)
        gg  = sb(2)
      end if

      if( sqrt(abs(gg)) < M_EPSILON ) then
        if(converged == ist - 1) converged = ist ! only consider the first converged eigenvectors
        !st%eigenval(ist, ik) = es(1) ! is this correct?
        res = sqrt(abs(gg))

        if(debug%info) then
          write(message(1), '(a,i4,a,i4,a,i4,a,es12.6,a,i4)') 'Debug: CG Eigensolver - ik', ik, &
               ' ist ', ist, ' iter ', iter, ' res ', res, " max ", maxter
          call messages_info(1)
        end if
        exit
      end if

      ! Starting or following iterations...
      if(iter  ==  1) then
        gg0 = gg
        do idim = 1, st%d%dim
          call lalg_copy(gr%mesh%np, g0(:,idim), cg(:, idim))
        end do
      else
        select case (optional_default(conjugate_direction, CG_FR))
        case (CG_FR)
          ! PTA eq. 5.20
          gamma = gg/gg0        ! (Fletcher-Reeves)
        case (CG_PR)
          gamma = (gg - gg1)/gg0   ! (Polack-Ribiere)
        case default
          call messages_input_error('Conjugate Direction')
        end select
        ! save for next iteration
        gg0 = gg

        ! PTA92, eq. 5.19
        forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
          cg(ip, idim) = gamma*cg(ip, idim) + g0(ip, idim) !!does this work unnormalized?!?!
        end forall

        ! PTA92, eq. 5.21
        norma =  X(mf_dotp) (gr%mesh, st%d%dim, psi, cg)
        forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
          cg(ip, idim) = cg(ip, idim) - norma*psi(ip, idim)
        end forall

        call profiling_count_operations(st%d%dim*gr%mesh%np*(2*R_ADD + 2*R_MUL))
      end if

! Modifications RDMFT
      ! cg contains now the conjugate gradient
      if(hm%theory_level == RDMFT) then
        ! In RDMFT different terms in the hamiltonian scale differently with occupation number
        ppsi2  = R_TOTYPE(M_ZERO)
        
        call X(hamiltonian_apply)(hm, gr%der, cg, h_cg, ist, ik, terms = TERM_KINETIC &
                                & + TERM_LOCAL_POTENTIAL + TERM_NON_LOCAL_POTENTIAL, set_occ = .true.)                !! 1-body+hartree ( hartree and external included in TERM_LOCAL_POTENTIAL) 
        call X(hamiltonian_apply)(hm, gr%der, cg, ppsi2, ist, ik, terms = TERM_OTHERS, set_occ = .true.)			 ! exchange
        h_cg = h_cg  + ppsi2
        
      else
        call X(hamiltonian_apply)(hm, gr%der, cg, h_cg, ist, ik)
      endif
! End RDMFT

      if(fold_) then
         call X(hamiltonian_apply)(hm, gr%der, h_cg, psi2, ist, ik)
         ! h_psi = (H-shift)^2 psi
         h_cg = psi2 - M_TWO*shift(ist,ik)*h_cg + shift(ist,ik)**2*cg
      end if

      ! Line minimization.
      a0 = X(mf_dotp) (gr%mesh, st%d%dim, psi, h_cg, reduce = .false.)
      b0 = X(mf_dotp) (gr%mesh, st%d%dim, cg, h_cg, reduce = .false.)
      cg0 = X(mf_nrm2) (gr%mesh, st%d%dim, cg, reduce = .false.)

      if(gr%mesh%parallel_in_domains) then
        sb(1) = a0
        sb(2) = b0
        sb(3) = cg0**2
        call comm_allreduce(gr%mesh%vp%comm, sb, dim = 3)
        a0 = sb(1)
        b0 = sb(2)
        cg0 = sqrt(sb(3))
      end if

      ! missing terms here? compare eq. 5.31
      a0 = M_TWO * a0 / cg0
      b0 = b0/cg0**2
      e0 = st%eigenval(ist, ik)
      ! old way of computing the angle
      !theta = atan(R_REAL(a0/(e0 - b0)))/M_TWO
      !es(1) = M_HALF*((e0-b0)*cos(M_TWO*theta) + a0*sin(M_TWO*theta) + e0 + b0)
      !es(2) = -M_HALF*((e0-b0)*cos(M_TWO*theta) + a0*sin(M_TWO*theta) - (e0 + b0))
      alpha = M_TWO * R_REAL(e0 - b0)
      beta = R_REAL(a0) * M_HALF
! Modifications RDMFT
			! Extra RDMFT part from lagrange multiplier in total functional: sum_ij lam_ij <phi_i|phi_j>
			! for current state (ist=i) beta_i -> beta_i - sum_k (lam_ki <cg_i|phi_k> + c.c.)
			!	with lam_ki = <phi_k|H|phi_i>
			if(hm%theory_level == RDMFT) then
				! calculate modification of beta
				beta_rdmft = M_ZERO
				do jst = 1, st%nst
					call states_get_state(st, gr%mesh, jst, ik, psi_lam)
					cg_phi(jst) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi_lam, cg))	
					beta_rdmft = beta_rdmft + cg_phi(jst) / cg0 * ( lam(jst) + lam_conj(jst) )
				end do
				beta = beta - beta_rdmft * M_HALF
			end if
! End RDMFT
      theta = atan(beta/alpha)*M_HALF
      stheta = sin(theta)
      ctheta = cos(theta)
      es(1) = alpha * (M_HALF - stheta**2) + beta*M_TWO*stheta*ctheta
      stheta2 = sin(theta + M_PI/M_TWO)
      ctheta2 = cos(theta + M_PI/M_TWO)
      es(2) = alpha * (M_HALF - stheta2**2) + beta*M_TWO*stheta2*ctheta2

      ! Choose the minimum solutions.
      if (R_REAL(es(2)) < R_REAL(es(1))) then
        theta = theta + M_PI/M_TWO
        a0 = ctheta2
        b0 = stheta2/cg0
      else
        a0 = ctheta
        b0 = stheta/cg0
      end if

      ! PTA92, eq. 5.38
      forall (idim = 1:st%d%dim, ip = 1:gr%mesh%np)
        psi(ip, idim) = a0*psi(ip, idim) + b0*cg(ip, idim)
        h_psi(ip, idim) = a0*h_psi(ip, idim) + b0*h_cg(ip, idim)
      end forall

      call profiling_count_operations(st%d%dim*gr%mesh%np*(2*R_ADD + 4*R_MUL))

      st%eigenval(ist, ik) = R_REAL(X(mf_dotp) (gr%mesh, st%d%dim, psi, h_psi))
      res = X(states_residue)(gr%mesh, st%d%dim, h_psi, st%eigenval(ist, ik), psi)

      ! consider change in energy
      if(iter == 1) then
        first_delta_e = abs(st%eigenval(ist, ik) - old_energy)
      end if

      if(debug%info .and. first_delta_e > M_ZERO) then
        write(message(1), '(a,i4,a,i4,a,i4,a,es12.5,a,es12.5,a,i4)') 'Debug: CG Eigensolver - ik', ik, ' ist ', ist, &
             !' iter ', iter, ' res ', res, ' ', res/norm, " max ", maxter
             ' iter ', iter, ' deltae ', abs(st%eigenval(ist, ik) - old_energy), ' ', abs(st%eigenval(ist, ik) - old_energy)/first_delta_e, " max ", maxter
        call messages_info(1)
      end if

      if(first_delta_e <= CNST(2.0)*M_EPSILON) then
        if(converged == ist - 1) converged = ist ! only consider the first converged eigenvectors
        exit iter_loop
      end if
      if(iter > 1) then
        if(abs(st%eigenval(ist, ik) - old_energy) < first_delta_e*CNST(1e-1)) then
          exit iter_loop
        end if
      end if
      old_energy = st%eigenval(ist, ik)

      ! Test convergence.
      if(res < tol) then
        ! require residue below tolerance for two consecutive steps
        if (iter > 1 .and. old_res < tol) then
          if(converged == ist - 1) converged = ist ! only consider the first converged eigenvectors
          exit iter_loop
        end if
      end if
      old_res = res

    end do iter_loop

    ! if the folded operator was used, compute the actual eigenvalue
    if(fold_) then
      call X(hamiltonian_apply)(hm, gr%der, psi, h_psi, ist, ik)
      st%eigenval(ist, ik) = X(mf_dotp) (gr%mesh, st%d%dim, psi, h_psi, reduce = .true.)
      res = X(states_residue)(gr%mesh, st%d%dim, h_psi, st%eigenval(ist, ik), psi)
    end if

    ! one could orthogonalize against all states here, but it turns out not
    ! to accelerate convergence
    call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, psi, normalize = .true.)
    call states_set_state(st, gr%mesh, ist, ik, psi)

    niter = niter + iter + 1

    if(present(diff)) then
      diff(ist) = res
    end if

    if(mpi_grp_is_root(mpi_world) .and. .not. debug%info) then
      call loct_progress_bar(st%lnst*(ik - 1) +  ist, st%lnst*st%d%kpt%nlocal)
    end if

  end do eigenfunction_loop

  ! Deallocation of variables
  SAFE_DEALLOCATE_A(psi)
  SAFE_DEALLOCATE_A(h_psi)
  SAFE_DEALLOCATE_A(g)
  SAFE_DEALLOCATE_A(g0)
  SAFE_DEALLOCATE_A(cg)
  SAFE_DEALLOCATE_A(h_cg)
  if(fold_) then
    SAFE_DEALLOCATE_A(psi2)
  end if
  
! Modifications Nicole
	if(hm%theory_level == RDMFT) then
		SAFE_DEALLOCATE_A(psi_lam)
		SAFE_DEALLOCATE_A(cg_vec_lam)
		SAFE_DEALLOCATE_A(lam)
		SAFE_DEALLOCATE_A(lam_conj)
		SAFE_DEALLOCATE_A(ppsi2)
	end if
! End Nicole

  POP_SUB(X(eigensolver_cg2))
end subroutine X(eigensolver_cg2)


! ---------------------------------------------------------
!> The algorithm is essentially taken from Jiang et al. Phys. Rev. B 68, 165337 (2003).
subroutine X(eigensolver_cg2_new) (gr, st, hm, tol, niter, converged, ik, diff)
  type(grid_t),        intent(in)    :: gr
  type(states_t),      intent(inout) :: st
  type(hamiltonian_t), intent(in)    :: hm
  FLOAT,               intent(in)    :: tol
  integer,             intent(inout) :: niter
  integer,             intent(inout) :: converged
  integer,             intent(in)    :: ik
  FLOAT,     optional, intent(out)   :: diff(:) !< (1:st%nst)

  integer :: nst, dim, ist, maxter, i, conv, ip, idim
  R_TYPE, allocatable :: psi(:,:), phi(:, :), hcgp(:, :), cg(:, :), sd(:, :), cgp(:, :)
  FLOAT :: ctheta, stheta, ctheta2, stheta2, mu, lambda, dump, &
    gamma, sol(2), alpha, beta, theta, theta2, res, norm
  R_TYPE :: dot
  logical, allocatable :: orthogonal(:)

  PUSH_SUB(X(eigensolver_cg2_new))

  dim = st%d%dim
  nst = st%nst

  maxter = niter
  niter = 0

  SAFE_ALLOCATE( phi(1:gr%mesh%np     , 1:dim))
  SAFE_ALLOCATE( psi(1:gr%mesh%np_part, 1:dim))
  SAFE_ALLOCATE(  cg(1:gr%mesh%np     , 1:dim))
  SAFE_ALLOCATE(hcgp(1:gr%mesh%np     , 1:dim))
  SAFE_ALLOCATE(  sd(1:gr%mesh%np     , 1:dim))
  SAFE_ALLOCATE( cgp(1:gr%mesh%np_part, 1:dim))
  SAFE_ALLOCATE(orthogonal(1:nst))

  phi(1:gr%mesh%np, 1:dim) = R_TOTYPE(M_ZERO)
  psi(1:gr%mesh%np, 1:dim) = R_TOTYPE(M_ZERO)
  cgp(1:gr%mesh%np, 1:dim) = R_TOTYPE(M_ZERO)

  ! Set the diff to zero, since it is intent(out)
  if(present(diff)) diff(1:st%nst) = M_ZERO

  conv = converged
  states: do ist = conv + 1, nst

    call states_get_state(st, gr%mesh, ist, ik, psi)

    ! Orthogonalize starting eigenfunctions to those already calculated...
    if(ist > 1) call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, psi, normalize = .true.)

    ! Calculate starting gradient: |hpsi> = H|psi>
    call X(hamiltonian_apply)(hm, gr%der, psi, phi, ist, ik)
    niter = niter + 1

    ! Initial settings for scalar variables.
    ctheta = M_ONE
    stheta = M_ZERO
    mu     = M_ONE

    ! Initialize to zero the vector variables.
    hcgp = R_TOTYPE(M_ZERO)
    cg   = R_TOTYPE(M_ZERO)

    orthogonal = .false.

    band: do i = 1, maxter - 1 ! One operation has already been made.

      if(mod(i, 5) == 0) orthogonal = .false.

      if( i >1 ) then ! Get H|psi> (through the linear formula)
        do idim = 1, st%d%dim
          do ip = 1, gr%mesh%np
            phi(ip, idim) = ctheta*phi(ip, idim) + stheta*hcgp(ip, idim)
          end do
        end do
      end if

      ! lambda = <psi|H|psi> = <psi|phi>
      lambda = X(mf_dotp)(gr%mesh, dim, psi, phi)

      ! Check convergence
      res = X(states_residue)(gr%mesh, dim, phi, lambda, psi)

      if(debug%info) then
        norm = X(mf_nrm2)(gr%mesh, dim, phi)
        write(message(1), '(a,i4,a,i4,a,i4,a,es12.6,a,es12.6)') 'Debug: CG New Eigensolver - ik', ik, &
          ' ist ', ist, ' iter ', i + 1, ' res ', res, ' ', res/norm
        call messages_info(1)
      end if

      if(present(diff)) diff(ist) = res
      if(res < tol) then
        if(conv == ist - 1) conv = ist
        exit band
      end if

      ! Get steepest descent vector
      do idim = 1, st%d%dim
        do ip = 1, gr%mesh%np
          sd(ip, idim) = lambda*psi(ip, idim) - phi(ip, idim)
        end do
      end do

      if(ist > 1) call X(states_orthogonalize_single)(st, gr%mesh, ist - 1, ik, sd, normalize = .false., mask = orthogonal)

      ! Get conjugate-gradient vector
      dump = X(mf_nrm2)(gr%mesh, dim, sd)**2
      gamma = dump/mu
      mu    = dump

      do idim = 1, st%d%dim
        do ip = 1, gr%mesh%np
          cg(ip, idim) = sd(ip, idim) + gamma*cg(ip, idim)
        end do
      end do

      dot = X(mf_dotp)(gr%mesh, dim, psi, cg)

      do idim = 1, st%d%dim
        do ip = 1, gr%mesh%np
          cgp(ip, idim) = cg(ip, idim) - dot*psi(ip, idim)
        end do
      end do

      norm = X(mf_nrm2)(gr%mesh, dim, cgp)

      call X(hamiltonian_apply)(hm, gr%der, cgp, hcgp, ist, ik)

      niter = niter + 1

      alpha = -lambda + R_REAL(X(mf_dotp)(gr%mesh, dim, cgp, hcgp))/norm**2
      beta  = M_TWO*R_REAL(X(mf_dotp)(gr%mesh, dim, cgp, phi))/norm
      theta = M_HALF*atan(-beta/alpha)
      ctheta = cos(theta)
      stheta = sin(theta)

      ! This checks whether we are picking the maximum or the minimum.
      theta2 = theta + M_PI/M_TWO
      ctheta2 = cos(theta2)
      stheta2 = sin(theta2)
      sol(1) = lambda + stheta**2*alpha + beta*stheta*ctheta
      sol(2) = lambda + stheta2**2*alpha + beta*stheta2*ctheta2

      if(sol(2) < sol(1)) then
        theta = theta2
        stheta = stheta2
        ctheta = ctheta2
      end if
      stheta = stheta/norm

      do idim = 1, st%d%dim
        do ip = 1, gr%mesh%np
          psi(ip, idim) = ctheta*psi(ip, idim) + stheta*cgp(ip, idim)
        end do
      end do

    end do band

    call states_set_state(st, gr%mesh, ist, ik, psi)

    st%eigenval(ist, ik) = lambda

    if(mpi_grp_is_root(mpi_world) .and. .not. debug%info) then
      call loct_progress_bar(st%lnst*(ik - 1) +  ist, st%lnst*st%d%kpt%nlocal)
    end if

  end do states

  converged = conv

  SAFE_DEALLOCATE_A(phi)
  SAFE_DEALLOCATE_A(psi)
  SAFE_DEALLOCATE_A(cg)
  SAFE_DEALLOCATE_A(hcgp)
  SAFE_DEALLOCATE_A(sd)
  SAFE_DEALLOCATE_A(cgp)
  SAFE_DEALLOCATE_A(orthogonal)

  POP_SUB(X(eigensolver_cg2_new))
end subroutine X(eigensolver_cg2_new)

!! Local Variables:
!! mode: f90
!! coding: utf-8
!! End:
